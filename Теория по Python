
--> Чем is отличается от '=='?
	Операторы is и == в Python выполняют сравнение объектов, но с различными подходами:
	is (тождественность): сравнивает объекты по их идентификаторам (адресам в памяти);
	== (равенство): сравнивает объекты по их значениям (содержимому).


--> Задача с изменением значения переменной:
    a = 10
    b = 10
    c = 300
    d = 300

    print(a is b)
    print(c is d)
    
    print(a is b)  # True
    print(c is d)  # False
    В этой задаче Python может проявить неожиданное поведение из-за механизма кэширования 
    маленьких целых чисел. Объекты a и b указывают на один и тот же объект в памяти
    из-за кэширования целых чисел в диапазоне от -5 до 256. Однако объекты c и d 
    указывают на разные объекты в памяти, потому что их значения выходят за этот диапазон.


--> Задача с использованием строк:
    str1 = "hello"
    str2 = "hello"
    str3 = str1[:]

    print(str1 is str2)
    print(str1 is str3)

    print(str1 is str2)  # True
    print(str1 is str3)  # False
    В этой задаче объекты str1 и str2 указывают на один и тот же объект в памяти из-за механизма 
    интернирования строк (пул строк). Однако str1 и str3 указывают на разные объекты в памяти, 
    поскольку str3 создан с использованием среза, что приводит к созданию нового объекта строки.


--> Задача с пустыми контейнерами:
    list1 = []
    list2 = []
    dict1 = {}
    dict2 = {}

    print(list1 is list2)
    print(dict1 is dict2)

    print(list1 is list2)  # False
    print(dict1 is dict2)  # False
    В этой задаче пустые списки и словари создаются как разные объекты в памяти. 
    Python не использует механизм интернирования для пустых контейнеров.


--> Что такое утиная типизация?
	- Утиная типизация (Duck typing) — это принцип в программировании, при котором тип или класс 
	объекта определяется его методами и свойствами, а не явным образом указанным интерфейсом или базовым классом.


--> Изменяемые и неизменяемые типы данных.
	Неизменяемые типы данных: int, float, str, tuple;
	Изменяемые типы данных: list, dict, set, bytearray;


--> Чем кортежи лучше листов?
	Лучше тем что из-за неизменяемости есть защита данных, также быстродействие особенно при большом объеме данных, 
	так как не требуется поддержка операций связанных с изменением структуры, и основные операции создания и доступ 
	к элементам буду более быстрее, поскольку не требуется проверка на изменения;


--> Функции для работы с листами.
	len(list), .append(x), .extend(iterable), .insert(index, x), .remove(x), .pop([index]), .index(x), .count(x) .sort(key=None, reverse=False);


--> Функции для работы с кортежами.
	len(tuple), .index(x), .count(x), .sorted(iterable, key=None, reverse=False), any(iterable) - хотя-бы один элемент True,
	all(iterable) - все элементы True, max(iterable), min(iterable), sum(iterable, start=0), enumerate(iterable, start=0),
	reversed(sequence), zip(iterable1, iterable2, ...) -Объединяет элементы из нескольких итерируемых объектов в кортежи;


--> Что такое множество?
	Множество – это неупорядоченная коллекция хешируемых объектов, которые не повторяются. 
	В множествах нет понятия позиции элемента. Соответственно, они не поддерживают индексацию и срезы. 
	Встроенные классы множеств: set (изменяемое множество), frozenset (неизменяемое множество).


--> Функции для работы с множествами.
	add(element), remove(element) - вызывает исключение если нет элемента, discard(element) - просто удаление;
	pop(), clear(), union(other_set);
	intersection(other_set) или & : множество, содержащее общие элементы двух множеств;
	difference(other_set) или - : множество, содержащее элементы, которые есть в первом множестве, но отсутствуют во втором;


--> Как соединить список строк в одну. .join()


--> Как разбить строку на список строк .split()


--> Способы обЪявления функций.
	def, lambda (анонимные функции), встроенные функции (result = max(10, 20)), внутри классов, внутри функций (вложенные функции),
	функции с переменным числом аргументов (def my_function(*args, **kwargs))
	args - кортеж с позиционными аргументами
	kwargs - словарь с именованными аргументами


--> Способы передачи параметров в Python.
	Позиционные параметры - Параметры передаются в том порядке, в котором они объявлены в определении функции.,
	Именованные параметры - Параметры передаются с указанием их имени, что позволяет изменять порядок передачи.,
	Значения параметров по умолчанию - def power(base, exponent=2):,
	Передача произвольного числа аргументов - def arbitrary_arguments(*args, **kwargs):.


--> Лямбда-функции в Python.
	Это анонимные функции, которые можно определить с использованием ключевого слова lambda. Они обычно 
	используются для создания коротких функций, которые выполняются в одной строке кода.
	lambda arguments: expression - expression: выражение, которое выполняется в теле функции и возвращается.


--> Как отсортировать список словарей по определенному полю: users.sort(key=lambda user: user['age'])


--> Что такое замыкание?
	Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. 
	При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. 
	Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней.


--> Как понять хешируемый ли объект?
	- В Python существует функция hash(), которая возвращает хеш-значение для указанного объекта. 
	- Однако не все объекты могут быть хешируемыми, и попытка вызова hash() для нехешируемого 
	объекта приведет к возникновению исключения TypeError.


-> Как работает хэш-таблица?
	- Хэш-таблица (hash table) — это структура данных, использующая хэш-функцию для преобразования входного ключа в индекс таблицы, 
	где обычно находится соответствующее значение.
	- Этапы работы хэш-таблицы:
	1) Хэш-функция:	Каждый уникальный ключ подается на вход хэш-функции, которая вычисляет хэш-код (хэш) для этого ключа.
	2) Индексация: Полученный хэш-код используется как индекс для доступа к соответствующему слоту (ячейке) в массиве (хэш-таблице).
	3) Коллизии: Коллизия происходит, когда два различных ключа имеют одинаковый хэш-код и пытаются занять один и тот же слот в хэш-таблице.
	- Решение коллизии: В каждом слоте хранится связанный список (цепочка) элементов, которые имеют одинаковые хэш-коды. 
	При коллизии новый элемент просто добавляется в этот список.
	4) Доступ и изменение: При поиске значения по ключу или добавлении нового элемента хэш-таблица снова 
	использует хэш-функцию для вычисления индекса и находит соответствующий слот.
	5) Динамическое изменение размера: Хэш-таблица может динамически изменять свой размер (рехэширование) для поддержки 
	изменения количества элементов. Это может происходить, например, при превышении определенного коэффициента 
	загруженности (load factor), который определяет, насколько заполнена хэш-таблица.


--> Где будет быстрее поиск, а где перебор и почему?
	Поиск будет быстрее в dict и set, потому что это хэш-таблицы, 
	доступ к элементу которых выполняется за O(1). Для list и tuple поиск будет выполняться в среднем за O(n).
	Исключение работает только для очень маленьких списков длиной до 5 элементов. 
	В этом случае интерпретатору будет быстрей пробежаться по списку, чем считать хеш.


--> Отличие copy() от deepcopy()?
	deepcopy() - создает новую и отдельную копию всего объекта или списка со своим уникальным адресом памяти. 
	Это означает, что любые изменения, внесенные вами в новую копию объекта или списка, не будут отражаться в исходной
	copy() - также создает отдельный новый объект или список, но вместо копирования дочерних элементов в новый объект 
	оно просто копирует ссылки на их адреса памяти.


--> Что такое list/dict comprehension?
	Выражение заключенное в квадратные/фигурные скобки, в котором используются ключевые слова for и in для 
	построения списка/словаря путем обработки и фильтрации элементов из одного или нескольких итерируемых объектов. 
	Списковое включение работает энергично.
	Энергичный - итерируемый объект, который сразу строит все свои элементы.


--> Создание списка квадратов чисел от 0 до 9:
    squares = [x**2 for x in range(10)]
    print(squares)  # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]


--> Фильтрация списка для получения только четных чисел:
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    even_numbers = [x for x in numbers if x % 2 == 0]
    print(even_numbers)  # Output: [2, 4, 6, 8, 10]


--> Преобразование списка строк в словарь с длиной строк в качестве значения:
    words = ["apple", "banana", "cherry"]
    word_lengths = {word: len(word) for word in words}
    print(word_lengths)  # Output: {'apple': 5, 'banana': 6, 'cherry': 6}


--> Магические методы.
	Называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием. Магические они потому, 
	что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции.
	__init__(self, ...) 	- Инициализация объекта, инициализирует атрибуты объекта после его создания;
	__str__(self)		- Возвращает строковое представление объекта. (print());
	__call__(self, ...) 	- Позволяет вызывать объект как функцию;

	__iter__(self) 		- Возвращает итератор для объекта;
	__next__(self)		- Возвращает следующий элемент итератора;

	__eq__(self, other)	- Определяет логику сравнения объектов на равенство (==);

	__enter__(self)		- Выполняется при входе в блок with;
	__exit__(self)		- При выходе из with;

	__dict__		- Словарь, содержащий атрибуты объекта;
	__slots__		- Механизм, позволяющий определить фиксированный набор атрибутов для экземпляра класса;
	__new__			- Метод, который создает новый экземпляр класса. Он является статическим методом и вызывается перед __init__;
	__name__ 		- Если скрипт импортируется как модуль в другом скрипте, то __name__ устанавливается в имя модуля;


--> Как получить список атрибутов объекта? Функция dir возвращает список строк – полей объекта. Поле __dict__ содержит словарь вида {поле -> значение}.


--> Как в классе сослаться на родительский класс? super(NextClass, self).__init__().


--> В чем смысл параметров _value, __value?
	- Поле класса с одним лидирующим подчеркиванием говорит о том, что параметр используется только внутри класса. 
	При этом он доступен для обращения извне. Это ограничение доступа только на уровне соглашения.
	- Поля с двойным подчеркиванием доступны внутри класса, но недоступны извне. 
	Это достигается хитрым приемом: интерпретатор назначает таким полям имена вида _<ClassName>__<fieldName>.


--> Чем отличаются итераторы от генераторов?
	- Итератор - это объект, который предоставляет последовательный доступ к элементам коллекции или данных. 
	- Итератор реализует два метода: __iter__ (возвращает сам итератор) и __next__ (возвращает следующий элемент последовательности). 
	Если больше элементов нет, метод __next__ должен поднимать исключение StopIteration.
	- Генератор - это специальный тип итератора, который создается с использованием ключевого слова yield. 
	- Генераторы позволяют создавать итераторы более компактно и эффективно, 
	поскольку сохраняют свое состояние между вызовами yield.
	- Итераторы могут занимать больше памяти, поскольку требуют явного хранения состояния в объекте класса.
	Генераторы сохраняют свое состояние между вызовами, что обычно приводит к более эффективному использованию памяти.
	- Используются: 
	- эффективный перебор элементов;
	- ленивая загрузка данных, когда не все элементы нужны;
	- генераторы могут создавать бесконечные последовательности;


--> Как объявить генератор?
	- использовать синтаксис (x for x in seq)
	- оператор yield в теле функции вместо return
	- встроенная функция iter, которая вызывает у объекта метод __iter__(). Этот метод должен возвращать генератор.


--> Что делает yield?
	- yield замораживает состояние функции-генератора и возвращает текущее значение. 
	После следующего вызова __next__() функция-генератор продолжает своё выполнение с 
	того места, где она была приостановлена.


--> Что делает enumerate в коде ниже?
    my_list = ['apple', 'banana', 'orange', 'grape']

    for index, fruit in enumerate(my_list):
        print(f"Index {index}: {fruit}")


--> Расписать свою версию enumerate как генератор
    def custom_enumerate(iterable, start=0):
    for i in range(start, len(iterable) + start):
        yield i, iterable[i - start]

    # Пример использования
    my_list = ['apple', 'banana', 'cherry']
    for index, value in custom_enumerate(my_list, start=1):
        print(index, value)


--> Как получить из генератора список? list(x for x in some_seq)


--> Какие методы есть у генераторов? 
	1) __next__() – начинает или продолжает исполнение функции-генератора.
	2) send(value) – продолжает выполнение и отправляет значение в функцию-генератор.
	3) throw(type[, value[, traceback]]) – выбрасывает исключение типа type в месте, где был приостановлен генератор, 
	и возвращает следующее значение генератора (или выбрасывает StopIteration).
	4) close() – выбрасывает исключение GeneratorExit в месте, где был приостановлен генератор. Если генератор 
	выбрасывает StopIteration (путём нормального завершения или по причине того, что он уже закрыт) или 
	GeneratorExit (путём отсутствия обработки данного исключения), close просто возвращается к месту вызова.


--> Можно ли извлечь элемент генератора по индексу? Нет, будет ошибка. Генератор не поддерживает метод __getitem__.


--> Что такое итерабельный объект?
	- Итерабельный объект (в оригинальной терминологии – «iterable») – это объект, который может возвращать значения 
	по одному за раз. Примеры: все контейнеры и последовательности (списки, строки и т.д.), файлы, а также 
	экземпляры любых классов, в которых определён метод __iter__() или __getitem__().


--> Исключения.
	- Исключения в программировании представляют собой события, которые происходят во время выполнения программы и 
	могут нарушить её нормальный ход. Обработка исключений позволяет программе справляться с ошибками, 
	обеспечивая контроль и понимание ситуации.
	- В Python исключения реализованы в виде объектов, и каждый класс исключения является 
	подклассом базового класса Exception. Примеры типов исключений в Python:
	- SyntaxError: Возникает при нарушении синтаксиса Python.
	- TypeError: Возникает, когда операция применяется к объекту несоответствующего типа.
	- IndexError: Возникает, когда индекс последовательности находится вне допустимого диапазона.


--> Декоратор
	- Это функция, которая принимает другую функцию и расширяет её функциональность, не изменяя её код.
	Используется: логирование, кэширование, измерение времени выполнения, аутентификация и авторизация.


--> Пример создания пустого декоратора с возможностью принятия произвольного количества позиционных и именованных аргументов:
    def empty_decorator(*args, **kwargs):
        def decorator(func):
            def wrapper(*args, **kwargs):
                # Реализация функции обертки (wrapper) может быть пустой
                return func(*args, **kwargs)
            return wrapper
        return decorator


--> Фабрика декораторов
	- Это функция, которая возвращает декоратор.


--> Менеджеры контекста (контекстный менеджер)
	- Это оператор with и обеспечивают выполнение кода в пределах определенного контекста. 
	Менеджер контекста гарантирует, что ресурсы будут правильно управляться, даже если произойдет исключение.
	Предоставляют удобный способ управления ресурсами, такими как файлы, сетевые соединения или базы данных.
	События входа и выхода из блока определены методами __enter__ и __exit__.


--> Что такое GIL?
	- GIL (Global Interpreter Lock) - это механизм внутри интерпретатора CPython, который обеспечивает мьютекс 
	для синхронизации выполнения потоков. Этот мьютекс предотвращает одновременное выполнение байт-кодов
	Python в нескольких потоках. GIL гарантирует каждому потоку эксклюзивный доступ к переменным интерпретатора
	- Принцип работы прост. Потоки удерживают GIL, пока выполняются. Однако они освобождают его при блокировании
	для операций ввода-вывода. Каждый раз, когда поток вынужден ждать, другие, 
	готовые к выполнению, потоки используют свой шанс запуститься.
	- GIL упрощает интеграцию non thread safe библиотек на С. Благодаря GIL у нас так много быстрых модулей и биндингов почти ко всему.
	- Библиотекам на C доступен механизм управления GIL. Так например NumPy отпускает его на долгих операциях.


--> В чем отличие multiprocessing от multithreading в Python?
	- Multiprocessing: Избегает проблемы GIL, так как каждый процесс имеет свой собственный интерпретатор Python и, 
	следовательно, свой собственный GIL.
	- Multithreading: Сталкивается с проблемой GIL, поскольку все потоки в пределах одного процесса используют общий GIL. 
	Это ограничивает параллельное выполнение кода в Python при использовании потоков.
	- Применение:
	- Multiprocessing: Полезен, когда требуется выполнение задач параллельно на разных ядрах процессора.
	Хорош для CPU-интенсивных задач.
	- Multithreading: Полезен для задач, которые могут выполняться параллельно и требуют общей памяти, 
	но может столкнуться с ограничениями GIL. Хорош для I/O-интенсивных задач.
	- Использование ресурсов:
	- Multiprocessing: Требует больше ресурсов (памяти и процессорного времени) из-за отдельных процессов.
	- Multithreading: Требует меньше ресурсов, так как все потоки используют общую память в рамках одного процесса.


--> IO-bound и CPU-bound задачи.
	1) IO-bound задачи:
	- Определение: Задачи, где основная часть времени тратится на ожидание ввода/вывода (I/O), например, 
	чтение/запись данных в файл, сетевые операции, запросы к базе данных и т.д.
	- Характеристики: Процессор ожидает завершения операции ввода/вывода.
	Повышение производительности может быть достигнуто параллельным выполнением нескольких IO-bound задач.
	Примеры: Загрузка данных из сети. Чтение/запись в файл. Выполнение базовых запросов к базе данных.
	2) CPU-bound задачи:
	- Определение: Задачи, где основная часть времени тратится на выполнение вычислительных операций, 
	например, обработка данных, вычисления, математические операции и т.д.
	- Характеристики: Процессор становится узким местом, так как задачи требуют большое количество вычислений. 
	Повышение производительности может быть достигнуто использованием многозадачности на уровне процессов 
	(для многозадачных систем) или многозадачности на уровне потоков (для многопоточных систем).
	- Примеры: Алгоритмы обработки изображений. Математические расчеты. Параллельные вычисления.


--> Как в питоне реализуется многопоточность. Какими модулями?
	- Многопоточность достигается модулем Threading. Это нативные Posix-треды. Такие треды 
	исполняются операционной системой, а не виртуальной машиной.


---> Что такое garbage collector. В чём его плюсы и минусы?
	- Сборщик мусора (Garbage Collector) в программировании — это механизм, отвечающий за автоматическое 
	управление памятью в программе. Он отслеживает объекты, которые больше не используются, и освобождает 
	для них память, предотвращая утечки памяти и облегчая жизнь программиста.
	- Плюсы сборщика мусора:
	1) Упрощение Управления Памятью: Сборщик мусора избавляет программиста от ручного выделения 
	и освобождения памяти, что упрощает разработку.
	2) Избегание Утечек Памяти: Сборщик мусора предотвращает утечки памяти, автоматически 
	освобождая память для объектов, которые больше не используются.
	3) Большая Производительность Разработки: Сборщик мусора ускоряет процесс разработки, позволяя 
	фокусироваться на более важных аспектах программы.
	- Минусы сборщика мусора:
	1) Недетерминированность: Точное время сборки мусора недетерминировано, что может привести к 
	неожиданным задержкам в работе программы.
	2) Сложность в Отношении Встраивания: В некоторых случаях встраивание сборщика мусора во 
	встроенные системы может быть сложным.
	- Алгоритм работы сборщика мусора:
	1) Подсчет Ссылок: Каждый объект в Python содержит счетчик ссылок. Когда создается новая ссылка на 
	объект, счетчик увеличивается. Когда ссылка удаляется, счетчик уменьшается.
	2) Циклический Сбор: Сборщик мусора Python способен обнаруживать циклические ссылки, когда 
	объекты формируют замкнутые циклы, и не могут быть доступны из основной программы. Циклический 
	сбор происходит в фоновом режиме.
	3) Поколения: Объекты делятся на три поколения: молодежь, средний возраст и старики. Объекты 
	сначала создаются в поколении молодежи. Если объект выживает один или несколько циклов сборки 
	мусора, он перемещается в поколение среднего возраста, а затем, при необходимости, в поколение старики.
	4) Инкрементальный Сбор: Сборка мусора в Python осуществляется инкрементально, поэтапно. Это позволяет 
	избежать длительных пауз в выполнении программы, поскольку сборка происходит по частям.
	5) Ручной Контроль: Разработчик Python также может управлять памятью вручную, используя модуль 
	gc и функции, такие как gc.collect() для явного вызова сборки мусора.