------------------- 1. Основы SQL ------------------------------------------

--> Что такое SQL и для чего он используется?
    - SQL (Structured Query Language) - это язык программирования, специально 
    разработанный для работы с реляционными базами данных. SQL предоставляет 
    стандартизированный набор команд для создания, изменения, управления и запросов 
    данных в базах данных.

--> Какие основные категории команд SQL вы знаете?
    1) DDL (Data Definition Language) - Команды Определения Данных:
    - CREATE: Создание объектов в базе данных, таких как таблицы, индексы, представления и др.
    - ALTER: Изменение структуры объектов, например, изменение таблицы путем добавления или удаления столбцов.
    - DROP: Удаление объектов, например, удаление таблицы или индекса.
    - TRUNCATE: Удаление всех записей из таблицы без удаления самой таблицы.
    - RENAME: Переименование объектов, таких как переименование таблицы.
    2) DML (Data Manipulation Language) - Команды Манипуляции Данными:
    - SELECT: Извлечение данных из таблицы.
    - INSERT: Вставка новых данных в таблицу.
    - UPDATE: Обновление существующих данных в таблице.
    - DELETE: Удаление данных из таблицы.
    3) DCL (Data Control Language) - Команды Управления Данными:
    - GRANT: Предоставление прав доступа к базе данных или ее объектам.
    - REVOKE: Отзыв прав доступа к базе данных или ее объектам.

--> Какие ключевые операторы SQL вы использовали?
    1) SELECT: Используется для извлечения данных из одной или нескольких таблиц.
    - SELECT column1, column2 FROM table_name WHERE condition;
    2) FROM: Указывает таблицу или представление, из которого извлекаются данные.
    3) WHERE: Фильтрует строки на основе заданного условия.
    - SELECT column1, column2 FROM table_name WHERE condition;
    4) ORDER BY: Сортирует результаты запроса по указанным столбцам в указанном 
    порядке (ASC - по возрастанию, DESC - по убыванию).
    5) GROUP BY: Группирует строки с одинаковыми значениями в указанных столбцах.
    6) HAVING: Фильтрует группы, созданные GROUP BY, на основе заданного условия.
    7) INSERT INTO: Вставляет новые строки в таблицу.
    8) UPDATE: Обновляет существующие записи в таблице.
    9) DELETE: Удаляет записи из таблицы.
    10) JOIN: Объединяет строки из двух или более таблиц на основе заданного условия.
    11) IN: Проверяет, содержится ли значение в списке значений.
    12) LIKE: Используется для сравнения строк с использованием шаблонов.

--> Как устроен базовый SQL-запрос SELECT? Какие параметры он поддерживает?
    - Базовый SQL-запрос SELECT используется для извлечения данных из таблицы или представления.
        SELECT column1, column2, ...
        FROM table_name
        WHERE condition;

------------------- 2. Операторы SELECT ------------------------------------

--> Как использовать оператор WHERE в SQL-запросе?
    - Оператор WHERE в SQL используется для фильтрации результатов запроса на основе 
    заданного условия. Он указывается после оператора FROM в SQL-запросе SELECT.

--> Какие операторы сравнения вы можете использовать в операторе WHERE?
    - Равно (Equal): SELECT * FROM employees WHERE salary = 50000;
    - Не равно (Not Equal): SELECT * FROM employees WHERE department_id <> 10;
    - Больше (Greater Than): SELECT * FROM employees WHERE department_id <> 10;
    - Меньше (Less Than): SELECT * FROM employees WHERE salary < 50000;
    - Больше или равно (Greater Than or Equal To): 
        SELECT * FROM employees WHERE salary >= 50000;
    - Меньше или равно (Less Than or Equal To):
        SELECT * FROM employees WHERE salary <= 50000;
    - IN (в списке значений): 
        SELECT * FROM employees WHERE department_id IN (10, 20, 30);
    - NOT IN (не в списке значений):
        SELECT * FROM employees WHERE department_id NOT IN (10, 20, 30);
    - LIKE (поиск по шаблону):
        SELECT * FROM employees WHERE first_name LIKE 'J%';
    %: Заменяет любое количество символов (включая ноль символов) в указанной позиции.
    _: Заменяет один символ в указанной позиции.
    - BETWEEN (в диапазоне):
        SELECT * FROM employees WHERE salary BETWEEN 50000 AND 70000;
    - IS NULL (пусто):
        SELECT * FROM employees WHERE manager_id IS NULL;
    - IS NOT NULL (не пусто):
        SELECT * FROM employees WHERE manager_id IS NOT NULL;

--> Что такое ORDER BY и как он используется?
    - Оператор ORDER BY в SQL используется для сортировки результатов запроса в 
    определенном порядке. Этот оператор следует за оператором SELECT в SQL-запросе.
        SELECT * FROM employees
        ORDER BY department_id ASC, salary DESC

--> Как работает GROUP BY? В каких случаях он полезен?
    - Оператор GROUP BY в SQL используется для группировки строк результирующего 
    набора по значениям одного или нескольких столбцов. Когда строки группируются, 
    агрегатные функции, такие как COUNT, SUM, AVG, MIN или MAX, могут быть 
    применены к данным внутри каждой группы.
        SELECT department_id, COUNT(*) as employee_count
        FROM employees
        GROUP BY department_id;
------------------- 3. Соединения (Joins) -----------------------------------

--> В чем разница между INNER JOIN и LEFT JOIN?
    1) INNER JOIN: Возвращает только те строки, для которых есть соответствующие 
    значения в обеих таблицах. То есть, если строка из одной таблицы не имеет 
    соответствия в другой таблице, она не будет включена в результирующий набор.
    INNER JOIN table2 ON table1.column = table2.column;
    2) LEFT JOIN (или LEFT OUTER JOIN): Возвращает все строки из левой (первой)
    таблицы и соответствующие строки из правой (второй) таблицы. Если строка из 
    левой таблицы не имеет соответствия в правой таблице, все значения в столбцах 
    правой таблицы будут равны NULL.
    LEFT JOIN table2 ON table1.column = table2.column;

--> Какие другие типы соединений вы знаете?
    3) RIGHT JOIN (или RIGHT OUTER JOIN): Возвращает все строки из правой (второй) 
    таблицы и соответствующие строки из левой (первой) таблицы. Если строки из 
    правой таблицы не имеют соответствия в левой таблице, соответствующие значения 
    в столбцах левой таблицы будут NULL.
    4) FULL JOIN (или FULL OUTER JOIN): Возвращает все строки из обеих таблиц. 
    Если строки из одной таблицы не имеют соответствия в другой таблице, 
    соответствующие значения будут NULL.
    5) CROSS JOIN: Возвращает декартово произведение строк из обеих таблиц, 
    то есть каждая строка из первой таблицы объединяется с каждой строкой из 
    второй таблицы.
    6) SELF JOIN: Это соединение таблицы с самой собой. Обычно используется 
    для работы с иерархическими данными или для поиска связей внутри одной таблицы.

------------------- 4. Агрегатные функции -----------------------------------

--> Какие агрегатные функции вы знаете?
    - Агрегатные функции в SQL используются для выполнения вычислений на данных в 
    столбцах и возвращения единственного значения. Вот некоторые из наиболее 
    часто используемых агрегатных функций:
    1) COUNT: Возвращает количество строк в результате запроса.
        SELECT COUNT(column_name) FROM table_name;
    2) SUM: Возвращает сумму значений в указанном столбце.
        SELECT SUM(column_name) FROM table_name;
    3) AVG: Возвращает среднее значение в указанном столбце.
        SELECT AVG(column_name) FROM table_name;
    4) MIN: Возвращает минимальное значение в указанном столбце.
        SELECT MIN(column_name) FROM table_name;
    5) MAX: Возвращает максимальное значение в указанном столбце.
        SELECT MAX(column_name) FROM table_name;
    6) GROUP BY: Используется для группировки строк на основе значений в одном или нескольких столбцах.
        GROUP BY column1;   
    7) HAVING: Фильтрует результаты группировки, аналогично условию WHERE, 
    но применяется к результатам группировки.
        SELECT column1, COUNT(column2)
        FROM table_name
        GROUP BY column1
        HAVING COUNT(column2) > 1;

------------------- 5. Индексы ----------------------------------------------

--> Что такое индексы в базе данных? Зачем они нужны?
    - Индексы в базе данных — это структуры данных, созданные для ускорения процесса 
    поиска и извлечения данных из таблицы. Они представляют собой отдельные объекты, 
    содержащие отсортированный набор значений и соответствующих указателей на строки 
    таблицы, где эти значения встречаются.
    - Индексы существенно улучшают производительность при выполнении операций SELECT, 
    JOIN и WHERE, но могут влиять на производительность операций INSERT, UPDATE и DELETE, 
    так как при изменении данных индексы также требуют обновления.

--> Какие виды индексов существуют?
    1) Кластерный индекс (Clustered Index):
    - Определяет физический порядок хранения данных в таблице.
    - Строки таблицы упорядочены в соответствии с значениями кластерного индекса.
    - В таблице может быть только один кластерный индекс.
    2) Некластерный индекс (Non-Clustered Index):
    - Не влияет на физический порядок данных в таблице.
    - Содержит пары значений ключей и указателей на соответствующие строки таблицы.
    - Таблица может иметь несколько некластерных индексов.
    3) Уникальный индекс (Unique Index):
    - Гарантирует уникальность значений в индексируемом столбце.
    - Может быть как кластерным, так и некластерным.
    4) Полнотекстовый индекс (Full-Text Index):
    - Используется для выполнения полнотекстового поиска в текстовых данных.
    5) Покрывающий индекс (Covering Index):
    - Включает в себя все столбцы, необходимые для выполнения запроса.
    - Уменьшает количество операций ввода/вывода, так как все данные для запроса содержатся в индексе.
    6) Составной индекс (Composite Index):
    - Создается на нескольких столбцах таблицы.
    - Ускоряет поиск по комбинации значений в этих столбцах.
    7) Битовый индекс (Bitmap Index):
    - Используется для индексации столбцов с ограниченным 
    числом уникальных значений, таких как булевы данные.
    8) Геоиндекс (Spatial Index):
    - Используется для работы с геопространственными данными, 
    такими как координаты местоположения.
    9) Агрегатный индекс (Bitmap Join Index):
    Используется в data warehousing для улучшения 
    производительности запросов, включающих агрегации.
    10) Хеш-индекс (Hash Index):
    - Используется для хеширования значений столбцов для быстрого поиска.

--> Плюсы использования индексов.
    - Ускорение операций поиска: Индексы позволяют базе данных быстро находить
    строки, соответствующие определенным критериям поиска (например, при
    использовании WHERE в SQL).
    - Ускорение операций сортировки: Индексы ускоряют сортировку данных,
    что полезно, когда результаты запроса должны быть представлены в
    отсортированном порядке.
    - Улучшение производительности при соединениях: При выполнении операций
    соединения (JOIN) индексы могут значительно ускорить выполнение запросов,
    связанных с несколькими таблицами.
    - Повышение производительности при использовании уникальных ограничений:
    Индексы могут использоваться для обеспечения уникальности значений в 
    столбцах, что помогает поддерживать целостность данных и ускоряет операции поиска.

--> Минусы использования индексов.
    - Затраты на хранение: Индексы занимают дополнительное место в базе
    данных. Чем больше индексов, тем больше места потребуется для
    хранения данных.

    - Затраты на обновление: При вставке, обновлении или удалении
    данных индексы также должны быть обновлены. Это может привести
    к дополнительным затратам по времени при выполнении операций записи.

    - Увеличение времени выполнения операций записи: Индексы могут
    замедлить операции записи данных в таблицу, так как при каждой
    записи происходит обновление индексов.

    - Неэффективность для некоторых запросов: Некоторые запросы
    могут не использовать индексы, и в этом случае использование
    индексов становится излишним.

--> Когда следует использовать индексы?
    - Когда таблица содержит большой объем данных.
    - Когда выполняются частые операции поиска.
    - Когда необходимо ускорить операции соединения между таблицами.
    - Когда необходимо соблюдать уникальность значений в столбцах.

--> Когда следует избегать использования индексов?
    - Для маленьких таблиц, где выигрыш в производительности несущественен.
    - Для таблиц, в которые часто вносятся изменения, и затраты на
    обновление индексов превышают выигрыш в производительности.
    - Для столбцов с низкой селективностью (т.е. значения в столбце 
    почти одинаковы для большинства строк), где индекс может быть неэффективен.

------------------- 6. Транзакции -------------------------------------------

--> Что такое транзакция в SQL?
    - Транзакция в SQL представляет собой последовательность одного или
    нескольких SQL-запросов, которые выполняются как единое целое. Транзакции 
    используются для обеспечения целостности данных и атомарности операций в базе данных.

--> Какие свойства ACID описывают транзакции?
    - ACID — это акроним, который описывает четыре основных свойства,
    обеспечиваемых транзакциями в базах данных:
    1) Атомарность (Atomicity): Гарантирует, что транзакция выполняется 
    целиком или не выполняется вообще. Если в процессе выполнения 
    транзакции происходит ошибка, все изменения, внесенные транзакцией 
    до момента ошибки, отменяются (откатываются).
    2) Согласованность (Consistency): Гарантирует, что транзакция переводит 
    базу данных из одного согласованного состояния в другое. После успешного 
    завершения транзакции база данных остается в согласованном состоянии, 
    соответствующем предопределенным правилам и ограничениям.
    3) Изолированность (Isolation): Обеспечивает изоляцию выполнения 
    транзакции от других параллельно выполняемых транзакций. Изолированность 
    предотвращает влияние одной транзакции на результаты других, обеспечивая, 
    что каждая транзакция выполняется, как если бы остальные транзакции не существовали.
    4) Долговечность (Durability): Гарантирует, что после успешного завершения 
    транзакции ее результаты остаются неизменными даже в случае сбоя системы 
    или выключения питания. Долговечность обеспечивает постоянство изменений, 
    внесенных транзакцией.

--> Может ли быть один запрос в транзакции БД?
    - Да, в базах данных можно выполнить несколько SQL-запросов в пределах одной транзакции. 
    Транзакции в базах данных предоставляют механизм для группировки нескольких операций
    в одну логическую единицу, где либо все операции выполняются успешно и
    сохраняются в базе данных (коммит), либо ни одна из них не выполняется (откат).

------------------- 7. Нормализация -----------------------------------------

--> Объясните, что такое нормализация баз данных.
    - Нормализация баз данных — это процесс проектирования и организации структуры
    базы данных с целью минимизации избыточности данных и предотвращения аномалий 
    при их обновлении. Целью нормализации является создание логически связанных, 
    эффективных и поддерживаемых баз данных.
    - Основные принципы нормализации включают в себя:
    1) Устранение дублирования данных: Повторяющиеся данные могут привести к 
    избыточности и трудностям в поддержке. Нормализация стремится к минимизации 
    дублирования данных, что уменьшает объем хранимой информации и улучшает ее 
    консистентность.
    2) Минимизация или устранение зависимостей: Нормализация устраняет ненужные 
    зависимости между данными, предотвращая такие проблемы, как обновление 
    аномалий (вставка, обновление или удаление данных, приводящее к 
    несогласованным или непредсказуемым результатам).
    3) Поддержание целостности данных: Структура данных после нормализации 
    обеспечивает более прочную целостность данных. Это означает, что данные
    в базе корректны и согласованы с предметной областью.
    - Процесс нормализации обычно разделяется на несколько нормальных форм 
    (1НФ, 2НФ, 3НФ и т.д.), каждая из которых вносит свои требования к структуре 
    данных. Основные шаги нормализации включают в себя анализ зависимостей, 
    выделение таблиц, разделение столбцов, создание связей между таблицами и 
    дополнительные шаги для достижения желаемого уровня нормализации.

--> Какие преимущества и недостатки нормализации?
    - Преимущества нормализации баз данных:
    1) Устранение избыточности данных: Нормализация помогает избежать 
    дублирования информации, что снижает объем хранимых данных и 
    улучшает их целостность.
    2) Повышение целостности данных: Благодаря структуре данных, 
    которая соответствует нормальным формам, уменьшается вероятность 
    появления аномалий при вставке, обновлении или удалении данных.
    3) Улучшение структуры запросов: Нормализация позволяет проводить 
    запросы к базе данных более эффективно и легко, так как данные 
    разделены по логическим сущностям.
    4) Сокращение места хранения: Избыточные данные занимают больше 
    места. Нормализация помогает экономить место, так как необходимая 
    информация хранится в одном месте.
    5) Повышение гибкости и поддерживаемости: Структура, соответствующая 
    нормальным формам, более гибкая и легко поддерживается при 
    изменениях в требованиях к данным.
    - Недостатки нормализации баз данных:
    1) Сложность запросов: Поскольку данные разделены по разным таблицам, 
    для получения полной информации иногда требуются сложные запросы с 
    использованием операторов JOIN.
    2) Увеличение числа таблиц: Нормализация может привести к большому 
    числу таблиц, что сделает базу данных менее понятной и увеличит 
    сложность управления.
    3) Потеря производительности: В случае сложных запросов и 
    большого объема данных может возникнуть потеря производительности, 
    особенно при использовании множественных соединений таблиц.
    4) Неэффективное использование памяти: В случае небольших баз 
    данных или при определенных типах запросов нормализация может 
    привести к неэффективному использованию памяти.
    5) Необходимость баланса: Нормализация требует баланса между 
    структурой данных и производительностью. Иногда полная нормализация 
    может быть излишней и привести к избыточности операций JOIN.

------------------- 8. Процедуры и функции ----------------------------------

--> Что такое процедура в SQL
    Хранимая процедура в SQL - это предварительно скомпилированный набор
    инструкций SQL, который может быть сохранен в базе данных и вызван '
    при необходимости.
    1) Многократное использование кода: Процедуры позволяют создавать 
    переиспользуемый код, который можно вызывать из различных частей приложения 
    или даже из разных приложений. Это сокращает дублирование кода и 
    упрощает его обслуживание.
    2) Улучшение производительности: Поскольку хранимые процедуры выполняются
    на сервере базы данных, они могут снизить объем передаваемых по сети 
    данных. Это может повысить производительность, особенно при работе с 
    большими объемами данных.
    3) Безопасность: Процедуры могут быть использованы для управления 
    доступом к данным. Пользователи могут иметь доступ только к выполнению 
    процедур, не имея прямого доступа к таблицам базы данных.
    4) Транзакционная поддержка: Хранимые процедуры могут включать в себя 
    несколько операторов SQL, обернутых в транзакции. Это позволяет 
    создавать безопасные и надежные операции с данными.
    5) Легкость обслуживания: Изменения в логике приложения могут быть 
    внесены в единственном месте - в самой процедуре, что упрощает 
    обслуживание и обновление кода.

--> Как создать хранимую процедуру в SQL?
    - Для создания хранимой процедуры в SQL обычно используется оператор 
    CREATE PROCEDURE. Вот пример простой хранимой процедуры:
        CREATE PROCEDURE имя_процедуры
        @параметр1 тип_параметра1,
        @параметр2 тип_параметра2
        AS
        BEGIN
            -- Тело процедуры с использованием параметров
            -- Например:
            SELECT * FROM ваша_таблица WHERE колонка1 = @параметр1 AND колонка2 = @параметр2;
        END;

--> В чем разница между хранимой процедурой и функцией?
    - Хранимые процедуры и функции в базах данных представляют собой
    программные объекты, которые можно создавать и вызывать для выполнения 
    определенных задач. Однако есть несколько ключевых различий между 
    хранимыми процедурами и функциями:
    1) Возвращаемое значение:
    - Хранимая процедура: Не обязана возвращать значение. Она может выполнять 
    различные действия, но не обязана возвращать результат.
    - Функция: Обязана возвращать значение. Функция предназначена для выполнения 
    вычислений и возвращения результата.
    2) Использование в выражениях:
    - Хранимая процедура: Не может быть использована в выражениях, так как 
    она не возвращает значение.
    - Функция: Может быть использована в выражениях, так как возвращает значение, 
    которое можно использовать далее в запросах.
    3) Транзакции:
    - Хранимая процедура: Может включать в себя несколько операторов SQL и
    управлять транзакциями внутри себя.
    - Функция: Ограничена более строгими правилами управления транзакциями. Например, 
    обычно функции не могут содержать операторы COMMIT или ROLLBACK.
    4) Использование параметров:
    - Хранимая процедура: Может содержать входные и выходные параметры, а 
    также параметры, передаваемые по ссылке.
    - Функция: Использует параметры для ввода значений, и она также может 
    возвращать одно значение в качестве результата.
    5) Вызов из SQL-запросов:
    - Хранимая процедура: Может быть вызвана из SQL-запросов, но

------------------- 9. Индексы и Оптимизация запросов -----------------------

--> Как оптимизировать SQL-запросы?
    - Оптимизация SQL-запросов – важная часть обеспечения производительности баз данных. Вот несколько общих рекомендаций по оптимизации SQL-запросов:
    1) Используйте Индексы:
    Создавайте индексы на столбцах, используемых в условиях WHERE и JOIN.
    Избегайте использования wildcard-символов в начале строк при поиске 
    (LIKE 'abc%'), так как они могут сделать индексы неэффективными.
    2) Выбирайте Только Необходимые Столбцы:
    Избегайте использования SELECT * и выбирайте только те столбцы, 
    которые действительно нужны.
    Это снижает объем передаваемых данных и ускоряет выполнение запросов.
    3) Оптимизируйте JOIN:
    Используйте правильные типы JOIN (INNER JOIN, LEFT JOIN и т.д.).
    Избегайте использования JOIN, если это не обязательно. 
    Иногда подзапросы или EXISTS могут быть более эффективными.
    4) Избегайте Использования Функций в Условиях:
    Использование функций в условиях (например, WHERE 
    YEAR(date_column) = 2022) может сделать индексы бесполезными.
    5) Оптимизируйте Запросы с Использованием Агрегаций: 
    При использовании агрегаций (SUM, AVG, MAX, MIN и т.д.), 
    убедитесь, что это необходимо.
    Используйте GROUP BY для агрегирования данных.
    6) Кэширование Результатов: 
    Рассмотрите возможность кэширования результатов запросов, 
    которые не часто изменяются.
    Кэширование может значительно снизить нагрузку на базу данных.
    7) Анализ и Профилирование:
    Используйте инструменты анализа выполнения запросов (query 
    execution plans) для оценки производительности.
    Профилируйте запросы и выявляйте узкие места.
    8) Обновляйте Статистику:
    Регулярно обновляйте статистику, которая помогает 
    оптимизатору запросов принимать правильные решения.

--> Как использовать индексы для ускорения выполнения запросов?
    1) Создавайте Индексы на Колонках, Используемых в Условиях WHERE:
    Оптимально создавать индексы на тех колонках, которые 
    участвуют в условиях WHERE запроса. Например:
        CREATE INDEX idx_username ON users(username);
    2) Индексы для Столбцов в Условиях JOIN:
    При использовании оператора JOIN создавайте индексы на столбцах, 
    участвующих в условиях объединения таблиц.
        CREATE INDEX idx_user_id ON orders(user_id);
    3) Индексы для Столбцов в Условиях Сортировки и Группировки:
    Если запрос включает операторы ORDER BY или GROUP BY, создайте 
    индексы для соответствующих столбцов.
        CREATE INDEX idx_creation_date ON posts(creation_date);
    4) Покрывающие Индексы (Covering Indexes):
    Создавайте покрывающие индексы, которые включают в себя все
    необходимые столбцы для выполнения запроса, чтобы избежать 
    обращения к самой таблице.
        CREATE INDEX idx_user_id_status ON orders(user_id, status);
    5) Объединенные (Composite) Индексы для Сложных Условий:
    Для сложных условий в запросах создавайте композитные индексы, 
    которые включают несколько столбцов.
        CREATE INDEX idx_last_name_first_name ON employees(last_name, first_name);  
    6) Обновляйте Статистику Индексов:
    Регулярно обновляйте статистику индексов, чтобы оптимизатор 
    запросов мог принимать более точные решения.
        UPDATE STATISTICS users;

-------------------10. Ограничения и Триггеры ------------------------------

--> Какие ограничения (constraints) вы знаете в SQL?
    - В SQL существует несколько типов ограничений (constraints), которые можно 
    применять для обеспечения целостности данных в базе данных. Вот некоторые из них:
    1) Ограничение уникальности (UNIQUE):
    - Гарантирует, что все значения в столбце или группе столбцов уникальны в 
    пределах всей таблицы.
        CREATE TABLE example (
          id INT PRIMARY KEY,
          username VARCHAR(50) UNIQUE
        );
    2) Ограничение первичного ключа (PRIMARY KEY):
    - Уникальный идентификатор строки в таблице. Он объединяет в себе ограничение
    уникальности и гарантирует непустоту.
        CREATE TABLE example (
          id INT PRIMARY KEY,
          username VARCHAR(50) UNIQUE
        );
    3) Ограничение внешнего ключа (FOREIGN KEY):
    - Устанавливает связь между двумя таблицами. Значения в столбце (или группе столбцов) 
    внешнего ключа должны совпадать с значениями в столбце (или группе столбцов) 
    первичного ключа в другой таблице.
        CREATE TABLE orders (
          order_id INT PRIMARY KEY,
          product_id INT,
          FOREIGN KEY (product_id) REFERENCES products(product_id)
        );
    4) Ограничение проверки (CHECK):
    - Ограничивает значения, которые могут быть вставлены в столбец, в соответствии 
    с заданным условием.
        CREATE TABLE example (
          age INT CHECK (age >= 18)
        );
    5) Ограничение непустоты (NOT NULL):
    - Гарантирует, что столбец не может содержать значения NULL.
        CREATE TABLE example (
          id INT NOT NULL,
          name VARCHAR(50) NOT NULL
        );
    6) Ограничение уникальности в пределах группы (UNIQUE внутри группы):
    - Гарантирует уникальность значений в пределах группы столбцов.
        CREATE TABLE example (
          department_id INT,
          employee_id INT,
          UNIQUE (department_id, employee_id)
        );

--> Что такое триггер в SQL?
    - Триггер в SQL представляет собой блок кода, который автоматически выполняется (или 
    "срабатывает") при определенных событиях, происходящих в базе данных. Эти события 
    могут включать в себя изменения в таблицах (например, вставка, обновление или удаление 
    записей), а также другие базовые операции.
    - Триггеры используются для автоматизации выполнения определенных действий или проверок 
    в ответ на изменения данных. Они являются частью механизма обеспечения целостности 
    данных в базе данных. Триггеры могут быть использованы для выполнения различных задач, 
    таких как ведение логов, обновление связанных таблиц, проверка данных перед вставкой 
    или обновлением и другие сценарии.
        CREATE TRIGGER trigger_name
        ON table_name
        AFTER INSERT, UPDATE, DELETE
        AS
        BEGIN
          -- Тело триггера: код, который будет выполнен при срабатывании триггера
        END;
    - trigger_name - имя триггера.
    - table_name - имя таблицы, для которой создается триггер.
    - AFTER INSERT, UPDATE, DELETE - указывает, на какие события триггер будет 
    реагировать (вставка, обновление, удаление).
    - AS - вводит тело триггера.
    - Триггеры бывают двух типов: AFTER (после события) и INSTEAD OF (вместо события). 
    AFTER триггеры срабатывают после завершения события, а INSTEAD OF триггеры могут 
    использоваться для замены действия по умолчанию.

------------------- 11. NoSQL и Другие Базы Данных --------------------------

--> В чем различия между SQL и NoSQL базами данных?
    - SQL (Structured Query Language) и NoSQL (Not Only SQL) представляют собой два различных 
    подхода к хранению и обработке данных в базах данных. Вот основные различия между ними:
    1) Тип данных и модель данных:
    - SQL: Использует реляционную модель данных, где данные организованы в таблицы 
    с жесткими схемами (структурами).
    - NoSQL: Имеет гибкую модель данных, которая может включать документы, ключ-значение, 
    столбцовые семейства или графовые структуры. NoSQL базы данных не требуют строгой схемы.
    2) Язык запросов:
    - SQL: Использует SQL для выполнения запросов и манипуляции данными.
    - NoSQL: Язык запросов зависит от конкретного вида NoSQL базы данных. 
    Например, MongoDB использует BSON-запросы (Binary JSON), Cassandra использует 
    CQL (Cassandra Query Language), а Redis использует команды на основе ключ-значение.
    3) Схема данных:
    - SQL: Требует строгой схемы данных. Изменение схемы может потребовать пересоздания 
    таблиц и может быть более сложным.
    - NoSQL: Позволяет гибкость в изменении схемы данных. Добавление новых полей 
    может быть легким и динамичным процессом.
    4) Масштабирование:
    - SQL: Традиционно применяется масштабирование вертикально (увеличение производительности 
    за счет добавления ресурсов на одном сервере).
    - NoSQL: Обычно лучше масштабируется горизонтально (добавление новых серверов 
    в распределенной системе).
    5) Транзакции:
    - SQL: Поддерживает ACID-транзакции (Atomicity, Consistency, Isolation, Durability), 
    обеспечивающие целостность данных.
    - NoSQL: Может поддерживать более слабые или гибкие гарантии целостности, 
    что может быть приемлемым в некоторых случаях.
    6) Применение:
    - SQL: Хорошо подходит для приложений с жесткой структурой данных, где требуется 
    поддержка сложных запросов и транзакций.
    - NoSQL: Эффективен для работы с неструктурированными или полуструктурированными данными, 
    а также в случаях, когда важна гибкость схемы данных и горизонтальное масштабирование.

--> Какие NoSQL базы данных вы знаете?
    - NoSQL: MongoDB, Cassandra, Redis, Couchbase.

------------------- 12. Работа с NULL и Полнотекстовый Поиск ----------------

--> Как обрабатывать NULL-значения в SQL-запросах?
    - Обработка NULL-значений в SQL-запросах важна для правильной работы с данными, 
    особенно при выполнении операций сравнения и агрегации. Вот несколько способов 
    обработки NULL-значений в SQL:
    1) IS NULL / IS NOT NULL:
    - Используйте предикат IS NULL для проверки, является ли значение NULL.
    - Используйте IS NOT NULL для проверки, является ли значение не NULL.
        SELECT column_name
        FROM table_name
        WHERE column_name IS NULL;
        
        SELECT column_name
        FROM table_name
        WHERE column_name IS NOT NULL;
    2) IFNULL (для MySQL) или ISNULL (для SQL Server):
    - IFNULL и ISNULL возвращают второй аргумент, если первый NULL.
        -- MySQL
        SELECT IFNULL(column_name, 'Default_Value') AS alias_name
        FROM table_name;
        
        -- SQL Server
        SELECT ISNULL(column_name, 'Default_Value') AS alias_name
        FROM table_name;
    - При использовании агрегатных функций, таких как SUM или AVG, учтите, что они 
    могут игнорировать NULL-значения.

--> Как реализовать полнотекстовый поиск в SQL?

------------------- 13. Безопасность ----------------------------------------

--> Как обеспечивается безопасность в базах данных?
    - Аутентификация и авторизация:
    - Шифрование данных:
    - Аудит и мониторинг:
    - Управление ролями и политиками безопасности:
    - Обновления и патчи:
    - Физическая безопасность:
    - Бекап и восстановление:
    - Firewalls и сетевая безопасность:
    - Управление паролями:
    - Обучение и осведомленность:

--> Как использовать роли для управления доступом?
    1) Создание ролей:
    - Создайте роли, которые отражают определенные функции или уровни доступа в вашей 
    системе. Например, роли могут быть "администратор", "пользователь", "редактор", и т. д.
        CREATE ROLE administrator;
        CREATE ROLE editor;
        CREATE ROLE user;
    2) Назначение пользователей ролям:
    - Назначьте соответствующие роли пользователям. Это можно сделать при создании 
    пользователя или позднее с использованием оператора GRANT.
        GRANT administrator TO some_user;
        GRANT editor TO another_user;
    3) Отзыв привилегий и ролей:
    - Привилегии и роли можно отзывать с использованием оператора REVOKE.
        REVOKE SELECT ON table_name FROM editor;

------------------- 14. Работа с Транзакциями и Изоляция --------------------

--> Какие уровни изоляции транзакций вы знаете?
    - Уровни изоляции транзакций определяют уровень видимости изменений, внесенных одной 
    транзакцией, для других транзакций. В стандарте SQL определены четыре уровня изоляции транзакций:
    1) READ UNCOMMITTED (Чтение неподтвержденных данных):
    Этот уровень предполагает минимальную изоляцию. Транзакции могут читать данные, которые были 
    изменены другими транзакциями, но еще не были подтверждены (неподтвержденные данные). Это может 
    привести к чтению "грязных данных" или данных, которые могут быть отменены после того, как транзакция, 
    внесшая изменения, откатится.
    2) READ COMMITTED (Чтение подтвержденных данных):
    Этот уровень гарантирует, что транзакции будут видеть только подтвержденные изменения. Грязное 
    чтение не разрешено, но возможно чтение неповторяющихся данных (несколько чтений в рамках 
    одной транзакции могут возвращать разные результаты).
    3) REPEATABLE READ (Повторяемое чтение):
    На этом уровне транзакция гарантирует, что будет видеть только те данные, которые 
    были подтверждены на момент ее начала. Это предотвращает грязное чтение и неповторяющееся 
    чтение. Однако, возможно чтение фантомных строк (новых строк, добавленных другой транзакцией).
    4) SERIALIZABLE (Сериализуемость):
    Это самый строгий уровень изоляции. Транзакции, выполняющиеся на этом уровне, гарантируют 
    полную изоляцию от изменений, внесенных другими транзакциями, что предотвращает грязное чтение,
    неповторяющееся чтение и чтение фантомных строк. Однако, это может привести к более высокой 
    степени блокировок и меньшей производительности.

--> Как обеспечить консистентность в многопользовательской среде?
    1) Транзакции:
    - Используйте транзакции для объединения нескольких операций в логическую единицу работы. 
    Транзакции могут быть подтверждены (COMMIT) или отменены (ROLLBACK). Это позволяет вам 
    обеспечить атомарность операций, то есть либо все операции выполняются успешно, 
    либо ни одна из них.
    2) Уровни изоляции транзакций:
    - Управляйте уровнями изоляции транзакций, чтобы определить, какие изменения видны 
    другим транзакциям в тот момент, когда одна из них выполняется. Выберите уровень 
    изоляции в зависимости от требований к консистентности данных.
    3) Блокировки:
    - Используйте блокировки для предотвращения конфликтов между параллельными транзакциями. 
    Блокировки могут быть различного типа, например, блокировки чтения и блокировки записи. 
    Однако, необходимо балансировать использование блокировок для предотвращения 
    избыточных блокировок, которые могут привести к долгим ожиданиям.
    4) Точки сохранения (Savepoints):
    - Используйте точки сохранения в транзакциях для определения мест, до которых можно 
    выполнить откат транзакции. Это может быть полезно для частичного отката 
    изменений в случае ошибки.
    5) Журнализация (Logging):
    - Ведите журнал всех изменений данных. Журнализация позволяет восстановить состояние 
    базы данных в случае сбоев или ошибок. Также, журнализация может использоваться 
    для воспроизведения последовательности действий.
    6) Оптимистическая блокировка:
    - Практика, при которой блокировки не применяются, и предполагается, что конфликты
    будут редкими. Вместо этого, система проверяет, не изменились ли данные с 
    момента начала транзакции.
    7) Использование индексов:
    - Создавайте индексы, чтобы ускорить доступ к данным и уменьшить время блокировки, 
    что может способствовать повышению производительности системы.

------------------- 15. Производительность и Оптимизация --------------------

--> Какие методы оптимизации производительности баз данных вы используете?
    - Оптимизация производительности баз данных включает в себя различные методы и 
    стратегии. Вот несколько общих методов оптимизации производительности баз данных:
    1) Индексирование:
    Создание эффективных индексов для ускорения операций выборки данных. Индексы 
    могут быть применены к столбцам, используемым в условиях WHERE, JOIN и ORDER BY.
    2) Нормализация и денормализация:
    Проектирование базы данных с использованием нормализации для избежания 
    избыточности данных. Однако, в некоторых случаях, денормализация может быть 
    использована для улучшения производительности запросов.
    3) Оптимизация запросов:
    Проверка и оптимизация запросов SQL для эффективного использования индексов, 
    минимизации использования ресурсов и ускорения выполнения.
    4) Кэширование:
    Использование кэширования для временного хранения результатов запросов или 
    часто используемых данных. Это может существенно снизить нагрузку на базу данных.
    5) Разделение данных:
    Разделение данных по различным таблицам, индексам, или даже серверам 
    для равномерного распределения нагрузки.
    6) Оптимизация структуры таблиц:
    Выбор подходящих типов данных, избегание избыточности и излишней 
    сложности структуры таблиц для улучшения производительности.
    7) Управление индексами:
    Анализ и оптимизация индексов, удаление неиспользуемых индексов, 
    выбор подходящих типов индексов (кластерные, некластерные).
    8) Оптимизация сервера баз данных:
    Настройка параметров сервера баз данных, таких как размер буферов, 
    пул соединений, параметры кэширования и т.д.
    9) Партиционирование данных:
    Разделение больших таблиц на части (партиции) согласно критериям, 
    таким как диапазон значений, что может улучшить производительность.
    10) Использование представлений (Views) и хранимых процедур:
    Использование представлений для упрощения сложных запросов и хранимых 
    процедур для оптимизации выполнения часто выполняемых операций.
    11) Мониторинг и профилирование:
    Регулярное мониторинг производительности базы данных, выявление узких мест и 
    проблем, и использование инструментов профилирования запросов.
    12) Горизонтальное и вертикальное масштабирование:
    Использование техник горизонтального (добавление серверов) и вертикального 
    (увеличение мощности существующего сервера) масштабирования для справления с ростом нагрузки.

--> Как избежать блокировок при выполнении транзакций?
    - Избегание блокировок при выполнении транзакций в базе данных важно для 
    обеспечения эффективности и производительности системы. Вот несколько 
    подходов, которые могут помочь в этом:
    1) Использование правильных уровней изоляции:
    Выберите подходящий уровень изоляции для ваших транзакций. В большинстве 
    случаев уровень изоляции READ COMMITTED может быть достаточным и эффективным.
    2) Минимизация времени удержания блокировки:
    Стремитесь минимизировать время, в течение которого транзакция 
    удерживает блокировку. Чем дольше удерживается блокировка, тем больше 
    вероятность возникновения конфликтов.
    3) Использование неблокирующих операторов:
    Воспользуйтесь операторами, которые не блокируют данные, например, операторами 
    безопасного чтения (например, NOLOCK в SQL Server) или операторами без 
    блокировок (например, SELECT ... FOR UPDATE NOWAIT в Oracle).
    4) Разделение транзакций:
    Разделяйте транзакции на более короткие и простые операции, чтобы уменьшить 
    вероятность блокировок. Это может включать в себя применение принципа 
    "разделяй и властвуй".
    5) Оптимизация индексов:
    Создание эффективных индексов на столбцах, используемых в условиях WHERE 
    и JOIN, может уменьшить вероятность блокировок при выполнении запросов.
    6) Использование снимков данных (snapshot isolation):
    В случае поддержки базой данных, использование снимков данных (snapshot isolation)
    может предотвратить блокировки, позволяя транзакциям читать представление
    данных на момент начала транзакции.
    7) Оптимизация структуры данных:
    Используйте правильные структуры данных и индексы для минимизации конфликтов 
    при доступе к данным.
    8) Тестирование и мониторинг:
    Регулярно тестируйте сценарии многопоточности и проводите мониторинг 
    блокировок в базе данных, чтобы оперативно выявлять и решать проблемы.
    9) Использование очередей и тайм-аутов:
    Разграничивайте доступ к ресурсам с использованием очередей и вводите 
    тайм-ауты для избежания долгих блокировок.
    10) Оптимизация запросов:
    Проанализируйте и оптимизируйте запросы, чтобы они эффективно использовали 
    индексы и минимизировали воздействие на замокаемые ресурсы.

------------------- 16. Работа с Большими Объемами Данных -------------------

--> Какие стратегии использования и хранения больших объемов данных в базе?
    1) Шардинг (Sharding):
    Распределение данных по нескольким узлам или серверам баз данных. 
    Каждый узел, или "шард", содержит только часть данных. Это позволяет 
    распределять нагрузку и увеличивать пропускную способность системы.
    2) Разделение данных на уровне приложения:
    Разделяйте данные на уровне приложения, например, с помощью множества 
    баз данных или схем, чтобы уменьшить нагрузку на каждую отдельную часть.
    3) Оптимизация структуры таблиц:
    Используйте правильные типы данных и индексы для оптимизации структуры 
    таблиц. Предварительное проектирование базы данных с учетом типов 
    запросов и операций может значительно повлиять на производительность.
    4) Кеширование:
    Используйте кеширование, чтобы уменьшить частоту обращений к базе данных. 
    Кэширование данных в памяти позволяет ускорить доступ к часто используемым данным.
    5) Компрессия данных:
    Применяйте методы сжатия данных для уменьшения объема хранимых 
    данных. Это может сэкономить место на диске и ускорить передачу данных.
    6) Базы данных NoSQL:
    Используйте базы данных NoSQL, такие как MongoDB, Cassandra, или Apache 
    HBase, которые спроектированы для работы с большими объемами данных и 
    горизонтального масштабирования.
    7) Использование хранилищ объектов:
    Рассмотрите возможность использования хранилищ объектов (Object Storage), 
    таких как Amazon S3 или Google Cloud Storage, для хранения больших объемов 
    неструктурированных данных, таких как изображения, видео или аудиофайлы.
    8) Управление временем жизни данных:
    Определите, как долго данные остаются актуальными, и используйте стратегии 
    автоматического удаления устаревших данных.
    9) Использование кластеров и облаков:
    Используйте кластеры баз данных и облачные решения для обеспечения 
    масштабируемости и управления ресурсами.
    10) Резервное копирование и восстановление:
    Разработайте стратегию резервного копирования и восстановления данных
    для обеспечения безопасности и целостности информации.
    11) Использование колоночных баз данных:
    Колоночные базы данных, такие как Google Bigtable или Apache Cassandra, 
    предоставляют эффективное хранение и доступ к большим объемам данных, 
    особенно при чтении и записи по столбцам.
