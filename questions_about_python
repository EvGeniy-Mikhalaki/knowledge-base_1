
--> Чем is отличается от '=='?
	Операторы is и == в Python выполняют сравнение объектов, но с различными подходами:
	is (тождественность): сравнивает объекты по их идентификаторам (адресам в памяти);
	== (равенство): сравнивает объекты по их значениям (содержимому).

--> Изменяемые и неизменяемые типы данных.
	Неизменяемые типы данных: int, float, str, tuple;
	Изменяемые типы данных: list, dict, set, bytearray;

--> Чем кортежи лучше листов?
	Лучше тем что из-за неизменяемости есть защита данных, также быстродействие особенно при большом объеме данных, 
	так как не требуется поддержка операций связанных с изменением структуры, и основные операции создания и доступ 
	к элементам буду более быстрее, поскольку не требуется проверка на изменения;

--> Функции для работы с листами.
	len(list), .append(x), .extend(iterable), .insert(index, x), .remove(x), .pop([index]), .index(x), .count(x) .sort(key=None, reverse=False);

--> Функции для работы с кортежами.
	len(tuple), .index(x), .count(x), .sorted(iterable, key=None, reverse=False), any(iterable) - хотя-бы один элемент True,
	all(iterable) - все элементы True, max(iterable), min(iterable), sum(iterable, start=0), enumerate(iterable, start=0),
	reversed(sequence), zip(iterable1, iterable2, ...) -Объединяет элементы из нескольких итерируемых объектов в кортежи;

--> Функции для работы со словарями.
	keys(), values(), items() - list(tupples(k, v)), get(key, default=None), pop(key, default=None);

--> Функции для работы с множествами.
	add(element), remove(element) - вызывает исключение если нет элемента, discard(element) - просто удаление;
	pop(), clear(), union(other_set);
	intersection(other_set) или & : множество, содержащее общие элементы двух множеств;
	difference(other_set) или - : множество, содержащее элементы, которые есть в первом множестве, но отсутствуют во втором;

--> Что такое множество?
	Множество – это неупорядоченная коллекция хешируемых объектов, которые не повторяются. 
	В множествах нет понятия позиции элемента. Соответственно, они не поддерживают индексацию и срезы. 
	Встроенные классы множеств: set (изменяемое множество), frozenset (неизменяемое множество).

--> Что такое контейнер?
	Контейнер – это тип данных, который инкапсулирует в себе значения других типов. 
	Списки, кортежи, множества, словари и т.д. являются контейнерами.

--> Как соединить список строк в одну. .join()

--> Как разбить строку на список строк .split()

--> Как отсортировать список словарей по определенному полю: users.sort(key=lambda user: user['age'])

--> Есть два списка – ключи и значения. Как составить из них словарь? dict(zip(keys, vals))

--> Как сравниваются последовательности?
	- Две последовательности равны, если они имеют одинаковый тип, равную длину и соответствующие элементы обоих последовательностей равны.

--> Как понять хешируемый ли объект?
	- В Python существует функция hash(), которая возвращает хеш-значение для указанного объекта. 
	- Однако не все объекты могут быть хешируемыми, и попытка вызова hash() для нехешируемого 
	объекта приведет к возникновению исключения TypeError.

-> Как работает хэш-таблица?
	- Хэш-таблица (hash table) — это структура данных, использующая хэш-функцию для преобразования входного ключа в индекс таблицы, 
	где обычно находится соответствующее значение.
	- Этапы работы хэш-таблицы:
	1) Хэш-функция:	Каждый уникальный ключ подается на вход хэш-функции, которая вычисляет хэш-код (хэш) для этого ключа.
	2) Индексация: Полученный хэш-код используется как индекс для доступа к соответствующему слоту (ячейке) в массиве (хэш-таблице).
	3) Коллизии: Коллизия происходит, когда два различных ключа имеют одинаковый хэш-код и пытаются занять один и тот же слот в хэш-таблице.
	- Решение коллизии: В каждом слоте хранится связанный список (цепочка) элементов, которые имеют одинаковые хэш-коды. 
	При коллизии новый элемент просто добавляется в этот список.
	4) Доступ и изменение: При поиске значения по ключу или добавлении нового элемента хэш-таблица снова 
	использует хэш-функцию для вычисления индекса и находит соответствующий слот.
	5) Динамическое изменение размера: Хэш-таблица может динамически изменять свой размер (рехэширование) для поддержки 
	изменения количества элементов. Это может происходить, например, при превышении определенного коэффициента 
	загруженности (load factor), который определяет, насколько заполнена хэш-таблица.

--> Где будет быстрее поиск, а где перебор и почему?
	Поиск будет быстрее в dict и set, потому что это хэш-таблицы, 
	доступ к элементу которых выполняется за O(1). Для list и tuple поиск будет выполняться в среднем за O(n).
	Исключение работает только для очень маленьких списков длиной до 5 элементов. 
	В этом случае интерпретатору будет быстрей пробежаться по списку, чем считать хеш.

--> Отличие copy() от deepcopy()?
	deepcopy() - создает новую и отдельную копию всего объекта или списка со своим уникальным адресом памяти. 
	Это означает, что любые изменения, внесенные вами в новую копию объекта или списка, не будут отражаться в исходной
	copy() - также создает отдельный новый объект или список, но вместо копирования дочерних элементов в новый объект 
	оно просто копирует ссылки на их адреса памяти.

--> Что такое list/dict comprehension?
	Выражение заключенное в квадратные/фигурные скобки, в котором используются ключевые слова for и in для 
	построения списка/словаря путем обработки и фильтрации элементов из одного или нескольких итерируемых объектов. 
	Списковое включение работает энергично.
	Энергичный - итерируемый объект, который сразу строит все свои элементы.



--> Способы обЪявления функций.
	def, lambda (анонимные функции), встроенные функции (result = max(10, 20)), внутри классов, внутри функций (вложенные функции),
	функции с переменным числом аргументов (def my_function(*args, **kwargs))
	args - кортеж с позиционными аргументами
	kwargs - словарь с именованными аргументами

--> Способы передачи параметров в Python.
	Позиционные параметры - Параметры передаются в том порядке, в котором они объявлены в определении функции.,
	Именованные параметры - Параметры передаются с указанием их имени, что позволяет изменять порядок передачи.,
	Значения параметров по умолчанию - def power(base, exponent=2):,
	Передача произвольного числа аргументов - def arbitrary_arguments(*args, **kwargs):.

--> Лямбда-функции в Python.
	Это анонимные функции, которые можно определить с использованием ключевого слова lambda. Они обычно 
	используются для создания коротких функций, которые выполняются в одной строке кода.
	lambda arguments: expression - expression: выражение, которое выполняется в теле функции и возвращается.

--> Что такое замыкание?
	Синтаксически это выглядит как функция, находящаяся целиком в теле другой функции. 
	При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. 
	Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней.



--> Принципы ООП. 
	1) Инкапсуляция - Позволяет скрыть внутренние детали реализации и предоставить интерфейс для взаимодействия с внешним миром.
	2) Наследование - Позволяет создавать новый класс на основе существующего (родительского) класса, наследуя его свойства и методы.
	3) Полиморфизм 	- Позволяет объектам разных типов обрабатываться с использованием общего интерфейса.
	4) Абстракция 	- Отделение сущности от ее конкретных деталей и представление ее как абстракции.
	5) Состояние 	- Управление состоянием объекта и его поведением осуществляется с использованием методов и свойств.
	6) Интерфейс 	- Определение совокупности методов и свойств, которые объект должен предоставлять
	7) Композиция 	- Позволяет создавать объекты с новым поведением, комбинируя уже существующие объекты.

--> Магические методы.
	Называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием. Магические они потому, 
	что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции.
	__init__(self, ...) 	- Инициализация объекта, инициализирует атрибуты объекта после его создания;
	__str__(self)		- Возвращает строковое представление объекта. (print());
	__call__(self, ...) 	- Позволяет вызывать объект как функцию;

	__iter__(self) 		- Возвращает итератор для объекта;
	__next__(self)		- Возвращает следующий элемент итератора;

	__eq__(self, other)	- Определяет логику сравнения объектов на равенство (==);

	__enter__(self)		- Выполняется при входе в блок with;
	__exit__(self)		- При выходе из with;

	__dict__		- Словарь, содержащий атрибуты объекта;
	__slots__		- Механизм, позволяющий определить фиксированный набор атрибутов для экземпляра класса;
	__new__			- Метод, который создает новый экземпляр класса. Он является статическим методом и вызывается перед __init__;
	__name__ 		- Если скрипт импортируется как модуль в другом скрипте, то __name__ устанавливается в имя модуля;

--> Как получить список атрибутов объекта? Функция dir возвращает список строк – полей объекта. Поле __dict__ содержит словарь вида {поле -> значение}.

--> Как в классе сослаться на родительский класс? super(NextClass, self).__init__().

--> В чем смысл параметров _value, __value?
	- Поле класса с одним лидирующим подчеркиванием говорит о том, что параметр используется только внутри класса. 
	При этом он доступен для обращения извне. Это ограничение доступа только на уровне соглашения.
	- Поля с двойным подчеркиванием доступны внутри класса, но недоступны извне. 
	Это достигается хитрым приемом: интерпретатор назначает таким полям имена вида _<ClassName>__<fieldName>.

--> Что такое MRO?
	MRO – method resolution order, порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей.

--> Что такое миксины?
	Миксин (mix-in, анг. “примесь”), паттерн проектирования в ООП, когда в цепочку наследования добавляется небольшой класс-помощник.

--> Геттеры и сеттеры.
	- Геттер - это метод, который используется для получения значения определенного атрибута объекта.
	Он обычно начинается с префикса "get" и возвращает значение атрибута.
	- Сеттер - это метод, который используется для установки значения определенного атрибута объекта. 
	Он обычно начинается с префикса "set" и принимает новое значение атрибута в качестве параметра.

--> Что такое метаклассы?
	Это механизм, который позволяет программистам изменять поведение классов. Метаклассы предоставляют 
	способ управления созданием классов, их атрибутами и методами на уровне метакласса.
	В Python классы являются объектами, и они создаются с использованием других классов, которые называются метаклассами.
	Типичный пример — Django ORM. class Person(models.Model): name = models.CharField(max_length=30) age = models.IntegerField()



--> Что такое утиная типизация?
	- Утиная типизация (Duck typing) — это принцип в программировании, при котором тип или класс 
	объекта определяется его методами и свойствами, а не явным образом указанным интерфейсом или базовым классом.

--> Что такое модуль?
	- Модуль – функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной её части.

--> Что такое файловый объект? 
	- Файловый объект – объект, предоставляющий файл-ориентированный API (методы read(), write() и т.д.) для доступа к ресурсу. 
	В зависимости от способа создания, файловый объект может предоставлять доступ к реальному файлу на диске или другому виду 
	устройства хранения или передачи данных (стандартные потоки ввода/вывода, буферы в памяти, сокеты и т.д.).
	Файловые объекты также называют потоками. Файловые объекты являются контекстными менеджерами.

--> Чем отличаются итераторы от генераторов?
	- Итератор - это объект, который предоставляет последовательный доступ к элементам коллекции или данных. 
	- Итератор реализует два метода: __iter__ (возвращает сам итератор) и __next__ (возвращает следующий элемент последовательности). 
	Если больше элементов нет, метод __next__ должен поднимать исключение StopIteration.
	- Генератор - это специальный тип итератора, который создается с использованием ключевого слова yield. 
	- Генераторы позволяют создавать итераторы более компактно и эффективно, 
	поскольку сохраняют свое состояние между вызовами yield.
	- Итераторы могут занимать больше памяти, поскольку требуют явного хранения состояния в объекте класса.
	Генераторы сохраняют свое состояние между вызовами, что обычно приводит к более эффективному использованию памяти.
	- Используются: 
	- эффективный перебор элементов;
	- ленивая загрузка данных, когда не все элементы нужны;
	- генераторы могут создавать бесконечные последовательности;

--> Как объявить генератор?
	- использовать синтаксис (x for x in seq)
	- оператор yield в теле функции вместо return
	- встроенная функция iter, которая вызывает у объекта метод __iter__(). Этот метод должен возвращать генератор.

--> Что делает yield?
	- yield замораживает состояние функции-генератора и возвращает текущее значение. 
	После следующего вызова __next__() функция-генератор продолжает своё выполнение с 
	того места, где она была приостановлена.

--> Что делает yield from?
	- yield from - это синтаксическое улучшение в языке программирования Python, 
	которое было введенов Python 3.3. Этот синтаксис облегчает делегирование
	работы генераторам.
	- Когда используется yield from, он делегирует выполнение другому генератору.
	Это позволяет создавать более чистый и структурированный код для работы с генераторами.
		def generator1():
		    yield 1
		    yield 2
		
		def generator2():
		    yield 'a'
		    yield 'b'
		
		def combined_generator():
		    yield from generator1()
		    yield from generator2()
		
		result = list(combined_generator())
		print(result)

--> Как получить из генератора список? list(x for x in some_seq)

--> Какие методы есть у генераторов? 
	1) __next__() – начинает или продолжает исполнение функции-генератора.
	2) send(value) – продолжает выполнение и отправляет значение в функцию-генератор.
	3) throw(type[, value[, traceback]]) – выбрасывает исключение типа type в месте, где был приостановлен генератор, 
	и возвращает следующее значение генератора (или выбрасывает StopIteration).
	4) close() – выбрасывает исключение GeneratorExit в месте, где был приостановлен генератор. Если генератор 
	выбрасывает StopIteration (путём нормального завершения или по причине того, что он уже закрыт) или 
	GeneratorExit (путём отсутствия обработки данного исключения), close просто возвращается к месту вызова.

--> Можно ли извлечь элемент генератора по индексу? Нет, будет ошибка. Генератор не поддерживает метод __getitem__.

--> Что такое итерабельный объект?
	- Итерабельный объект (в оригинальной терминологии – «iterable») – это объект, который может возвращать значения 
	по одному за раз. Примеры: все контейнеры и последовательности (списки, строки и т.д.), файлы, а также 
	экземпляры любых классов, в которых определён метод __iter__() или __getitem__().



--> Исключения.
	- Исключения в программировании представляют собой события, которые происходят во время выполнения программы и 
	могут нарушить её нормальный ход. Обработка исключений позволяет программе справляться с ошибками, 
	обеспечивая контроль и понимание ситуации.
	- В Python исключения реализованы в виде объектов, и каждый класс исключения является 
	подклассом базового класса Exception. Примеры типов исключений в Python:
	- SyntaxError: Возникает при нарушении синтаксиса Python.
	- TypeError: Возникает, когда операция применяется к объекту несоответствующего типа.
	- IndexError: Возникает, когда индекс последовательности находится вне допустимого диапазона.

--> Декоратор
	- Это функция, которая принимает другую функцию и расширяет её функциональность, не изменяя её код.
	Используется: логирование, кэширование, измерение времени выполнения, аутентификация и авторизация.

--> Фабрика декораторов
	- Это функция, которая возвращает декоратор.

--> Менеджеры контекста (контекстный менеджер)
	- Это оператор with и обеспечивают выполнение кода в пределах определенного контекста. 
	Менеджер контекста гарантирует, что ресурсы будут правильно управляться, даже если произойдет исключение.
	Предоставляют удобный способ управления ресурсами, такими как файлы, сетевые соединения или базы данных.
	События входа и выхода из блока определены методами __enter__ и __exit__.



--> Что такое GIL?
	- GIL (Global Interpreter Lock) - это механизм внутри интерпретатора CPython, который обеспечивает мьютекс 
	для синхронизации выполнения потоков. Этот мьютекс предотвращает одновременное выполнение байт-кодов
	Python в нескольких потоках. GIL гарантирует каждому потоку эксклюзивный доступ к переменным интерпретатора
	- Принцип работы прост. Потоки удерживают GIL, пока выполняются. Однако они освобождают его при блокировании
	для операций ввода-вывода. Каждый раз, когда поток вынужден ждать, другие, 
	готовые к выполнению, потоки используют свой шанс запуститься.
	- GIL упрощает интеграцию non thread safe библиотек на С. Благодаря GIL у нас так много быстрых модулей и биндингов почти ко всему.
	- Библиотекам на C доступен механизм управления GIL. Так например NumPy отпускает его на долгих операциях.

--> В чем отличие multiprocessing от multithreading в Python?
	- Multiprocessing: Избегает проблемы GIL, так как каждый процесс имеет свой собственный интерпретатор Python и, 
	следовательно, свой собственный GIL.
	- Multithreading: Сталкивается с проблемой GIL, поскольку все потоки в пределах одного процесса используют общий GIL. 
	Это ограничивает параллельное выполнение кода в Python при использовании потоков.
	- Применение:
	- Multiprocessing: Полезен, когда требуется выполнение задач параллельно на разных ядрах процессора.
	Хорош для CPU-интенсивных задач.
	- Multithreading: Полезен для задач, которые могут выполняться параллельно и требуют общей памяти, 
	но может столкнуться с ограничениями GIL. Хорош для I/O-интенсивных задач.
	- Использование ресурсов:
	- Multiprocessing: Требует больше ресурсов (памяти и процессорного времени) из-за отдельных процессов.
	- Multithreading: Требует меньше ресурсов, так как все потоки используют общую память в рамках одного процесса.

--> IO-bound и CPU-bound задачи.
	1) IO-bound задачи:
	- Определение: Задачи, где основная часть времени тратится на ожидание ввода/вывода (I/O), например, 
	чтение/запись данных в файл, сетевые операции, запросы к базе данных и т.д.
	- Характеристики: Процессор ожидает завершения операции ввода/вывода.
	Повышение производительности может быть достигнуто параллельным выполнением нескольких IO-bound задач.
	Примеры: Загрузка данных из сети. Чтение/запись в файл. Выполнение базовых запросов к базе данных.
	2) CPU-bound задачи:
	- Определение: Задачи, где основная часть времени тратится на выполнение вычислительных операций, 
	например, обработка данных, вычисления, математические операции и т.д.
	- Характеристики: Процессор становится узким местом, так как задачи требуют большое количество вычислений. 
	Повышение производительности может быть достигнуто использованием многозадачности на уровне процессов 
	(для многозадачных систем) или многозадачности на уровне потоков (для многопоточных систем).
	- Примеры: Алгоритмы обработки изображений. Математические расчеты. Параллельные вычисления.

--> Как в питоне реализуется многопоточность. Какими модулями?
	- Многопоточность достигается модулем Threading. Это нативные Posix-треды. Такие треды 
	исполняются операционной системой, а не виртуальной машиной.

---> Что такое garbage collector. В чём его плюсы и минусы?
	- Сборщик мусора (Garbage Collector) в программировании — это механизм, отвечающий за автоматическое 
	управление памятью в программе. Он отслеживает объекты, которые больше не используются, и освобождает 
	для них память, предотвращая утечки памяти и облегчая жизнь программиста.
	- Плюсы сборщика мусора:
	1) Упрощение Управления Памятью: Сборщик мусора избавляет программиста от ручного выделения 
	и освобождения памяти, что упрощает разработку.
	2) Избегание Утечек Памяти: Сборщик мусора предотвращает утечки памяти, автоматически 
	освобождая память для объектов, которые больше не используются.
	3) Большая Производительность Разработки: Сборщик мусора ускоряет процесс разработки, позволяя 
	фокусироваться на более важных аспектах программы.
	- Минусы сборщика мусора:
	1) Недетерминированность: Точное время сборки мусора недетерминировано, что может привести к 
	неожиданным задержкам в работе программы.
	2) Сложность в Отношении Встраивания: В некоторых случаях встраивание сборщика мусора во 
	встроенные системы может быть сложным.
	- Алгоритм работы сборщика мусора:
	1) Подсчет Ссылок: Каждый объект в Python содержит счетчик ссылок. Когда создается новая ссылка на 
	объект, счетчик увеличивается. Когда ссылка удаляется, счетчик уменьшается.
	2) Циклический Сбор: Сборщик мусора Python способен обнаруживать циклические ссылки, когда 
	объекты формируют замкнутые циклы, и не могут быть доступны из основной программы. Циклический 
	сбор происходит в фоновом режиме.
	3) Поколения: Объекты делятся на три поколения: молодежь, средний возраст и старики. Объекты 
	сначала создаются в поколении молодежи. Если объект выживает один или несколько циклов сборки 
	мусора, он перемещается в поколение среднего возраста, а затем, при необходимости, в поколение старики.
	4) Инкрементальный Сбор: Сборка мусора в Python осуществляется инкрементально, поэтапно. Это позволяет 
	избежать длительных пауз в выполнении программы, поскольку сборка происходит по частям.
	5) Ручной Контроль: Разработчик Python также может управлять памятью вручную, используя модуль 
	gc и функции, такие как gc.collect() для явного вызова сборки мусора.
